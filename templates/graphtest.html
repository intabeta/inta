<html>
<head>
<style>
.brian_nav .inta_brand {
 color: #ddf;
 display: inline;
 float:left;
 font-size:26px;
 margin: 5px 15px 0px 20px;
 /*border-bottom: 2px solid white;*/
}
.brian_nav {
  position: fixed;
  top:0%;
  right:0%;
  left:0%;
  z-index: 20000;
  overflow: hidden;
  background-color: black;
  border-bottom: 1px solid #000;
  height: 40px;
}
.nav_row {
  display:inline-block;
  margin-bottom: 0px;
  padding-bottom: 0px;
}
.brian_nav p {
  display:inline-block;
  padding-bottom: 2px;
  margin: 12px 5px 12px 0px;
  font-weight:bold;
  font-size: 15px;
}
.brian_nav p a {
  color: white;
  text-decoration: none;
}
.nav_row--hide p {
  color: white;
}
.brian_nav p a:hover {
  text-decoration: none;
  color: #ddf;
}
.brian_nav .active > a {
  border-bottom: 2px solid white;
  color: #ddf;
}
.underline_title {
 border-bottom: 2px solid white;
}
</style>

</head>
<body onload="initialize();" style="background-color: #ddf">
 <div class="brian_nav">
  <div class="nav_row" id="time_nav">
      <p class="inta_brand"><a href="/{{ method }}" style="color:#ddf" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest Inta link']);" onClick="_gaq.push(['_trackEvent', 'graphtest', 'Inta link']);"> inta </a></p>
        <p {% if method == 'decay1' %}class="active"{% endif %}><a href="/graphtest/decay1" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest 30m']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '30m']);">30m</a></p>
        <p {% if method == 'decay2' %}class="active"{% endif %}><a href="/graphtest/decay2" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest 3h']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '3h']);">3h</a></p>
        <p {% if method == 'decay3' %}class="active"{% endif %}><a href="/graphtest/decay3" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest 1d']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '1d']);">1d</a></p>
        <p {% if method == 'decay4' %}class="active"{% endif %}><a href="/graphtest/decay4" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest 3d']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '3d']);">3d</a></p>
        <p {% if method == 'decay5' %}class="active"{% endif %}><a href="/graphtest/decay5" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest 1w']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '1w']);">1w</a></p>
        <p {% if method == 'decay6' %}class="active"{% endif %}><a href="/graphtest/decay6" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest 4w']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '4w']);">4w</a></p>
        <p {% if method == 'decay7' %}class="active"{% endif %}><a href="/graphtest/decay7" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest 12w']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '12w']);">12w</a></p>
        <p {% if method == 'decay8' %}class="active"{% endif %}><a href="/graphtest/decay8" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest yr']);" onClick="_gaq.push(['_trackEvent', 'graphtest', 'yr']);">yr</a></p>
        <p {% if method == 'votes' %}class="active"{% endif %}><a href="/graphtest/votes" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest all']);" onClick="_gaq.push(['_trackEvent', 'graphtest', 'all']);">All-time</a></p>
    </div>
</div>

  <!-- <div style="display:inline-block; float:left; margin-left: 0px; margin-top: 40px; border: 1px solid black">
    <div id='link' onmousedown="_gaq.push(['_trackEvent', '', 'graphtest link click']);" onClick="_gaq.push(['_trackEvent', 'graphtest', 'list link', '']);"></div>
    <p style="font-size: 14px; font-weight:bold; width: 400px; float:left;">We're playing with a "universe" type view to see all of Inta's web. Let us know if you like it or have ideas for it. <a href="mailto:christopher.shriver@yale.edu?subject=The Inta Universe"> christopher.shriver@yale.edu</a> is the architect </p> 
    <br/>
    <ul style="font-size: 14px; width: 400px; float:left"> 
      <li>Each node (dot) is a tag</li>
        <ul>
          <li>Tags get bigger with more votes</li>
          <li>Hover to see the tag name (and vote count)</li>
          <li>Click to create a link to Inta for that tag</li>
        </ul>
        <br>
      <li>Tags with connecting lines have shared links</li>
        <ul>
          <li>The darker the line, the more links</li>
        </ul>
        <br>
      <li>Click different time periods above to alter the universe</li>
        <ul>
          <li>Tags with 0 votes in a time period will disappear</li>
        </ul>
  </ul>
  </div> -->
  <div style="margin-left: 0px; -moz-user-select: none; -webkit-user-select: none; position: absolute; top: 40px; left:0px;" onselectstart='return false;'>
      <canvas id="viewpane" width="600" height="600" style="border: 1px solid black; background-color:rgb(250,250,245); margin-top:0px; margin-bottom: 30px; position: absolute; left: 0; top: 0; z-index: 0">Canvas not supported.</canvas>
      <canvas id="map" width="100" height="100" style="border: 1px solid black; background-color:rgba(255,255,255,0.7); position: absolute; left: 10; top: 10; z-index: 1"></canvas>
      <canvas id="sidebar" width="200" height="100" style="border: 1px solid black; background-color:rgba(255,255,255,0.5); position: absolute; left:0; top: 0; z-index: 1"></canvas>
      <input id='search' type='text' size='30' value="Find tag" style="position:absolute; left:100; top:100; z-index:2; width:150px; height:19px;">
  </div>
  
<!--
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-32641734-1');
ga('send', 'pageview');
-->


</body>
<script type="text/javascript">
var canvas = document.getElementById("viewpane");
var mapcanvas = document.getElementById("map");
var sidebar = document.getElementById("sidebar");
var searchinput = document.getElementById("search");

var width = 600;
var height = 600;
var sidebarw = 200;

var ctx=canvas.getContext("2d");
var mapctx=mapcanvas.getContext("2d");
var sidectx=sidebar.getContext("2d");

var X;
var Y;

var points={% autoescape off %}{{ points }}{% endautoescape %};
var edges={{ edges }};
var forces=points.map(function(p) { return [0,0]; });
var velocities=points.map(function(p) { return [0,0]; });
var radii=points.map(function(p) { return 2*Math.log(p[3]+1); });
var rad = 3;
var drawpoints = points;
var mappoints = points;

var selected = -1;
var inLink = false;
var link=0;
var links = [];
var linkhover = -1;

var loading = 1;
var maxv = 0;
var info = 1;
var infoclosehover = 0;

var panpoint = [0,0];
var panning = 0;

var zoomdisp = 1;
var zooming = 0;
var zoomhilight = 0;

var minx = 0; //these seven variables are used in updateframe()
var maxx = 0;
var miny = 0;
var maxy = 0;
var xrange = 0;
var yrange = 0;
var framer = 0;
var zoom = 2; //equal to canvas width divided by view width
var viewc = [300,300]; //center of view

var damp = 0.5; //how much to damp motion to prevent things from oscillating indefinitely and/or getting out of control
var stiffness = 10; //stiffness of springs
var spread = 40; //ideal length of springs
var k = 300000; //like the constant in coulomb's law


function min(array) {
    return Math.min.apply(null,array);
}
function max(array) {
    return Math.max.apply(null,array);
}

var maxedge = max(edges.map(function(e) { return e[2]; }));

function initialize() {
  canvas.addEventListener("mousemove", on_mousemove, false);
  mapcanvas.addEventListener("mousemove", on_mousemove_map, false);
  sidebar.addEventListener("mousemove", on_mousemove_sidebar, false);
  canvas.addEventListener("mousedown", on_down, false);
  mapcanvas.addEventListener("mousedown", on_down_map, false);
  sidebar.addEventListener("mousedown", on_down_sidebar, false);
  canvas.addEventListener("mouseup", on_up, false);
  mapcanvas.addEventListener("mouseup", on_up, false);
  canvas.addEventListener("mousewheel",function(ev){
    scroll(ev);
    ev.preventDefault();
    return false;
  },false);
  window.addEventListener("resize", resize, false);
  //size things to fit the window
  var w = window.innerWidth;
  var h = window.innerHeight;
  width = w-sidebarw;
  height = h;
  canvas.width = w;
  canvas.height = h;
  sidebar.style.left = w-sidebarw;
  sidebar.height = h;
  searchinput.style.left = w-sidebarw+10;
  searchinput.style.top = h-searchinput.style.height.slice(0,-2)-10-40;
  searchinput.style.width = sidebarw-20;
  //start everything
  update();
  updateframe();
  loading = 1; //set loading to 1 after running update() once, otherwise all the velocities will be zero and update will set loading back to 0
}

// draw things
function draw() {
  // check if supported
  if(canvas.getContext) {
    //clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    //draw edges
    for (i=0;i<edges.length;i++) {
      ctx.beginPath();
      ctx.strokeStyle='rgba(0,0,0,'+String(edges[i][2]/50)+')';
      X1=drawpoints[edges[i][0]][0];
      Y1=drawpoints[edges[i][0]][1];
      X2=drawpoints[edges[i][1]][0];
      Y2=drawpoints[edges[i][1]][1];
      ctx.moveTo(X1,Y1);
      ctx.lineTo(X2,Y2);
      ctx.stroke();
      ctx.closePath();
    }

    //hilight hovered node
    if (inLink) {
      ctx.fillStyle = "#ddddff";
      ctx.beginPath();
      X=drawpoints[link][0];
      Y=drawpoints[link][1];
      rad = radii[link]*1.2*zoom;
      ctx.moveTo(X+rad,Y);
      ctx.arc(X,Y,rad,0,Math.PI*2,true);
      ctx.fill();
      ctx.closePath();
      ctx.fillStyle = "#aaaaff";
      ctx.beginPath();
      rad *= 0.9;
      ctx.moveTo(X+rad,Y);
      ctx.arc(X,Y,rad,0,Math.PI*2,true);
      ctx.fill();
    }

    //draw the nodes if they are in the view pane
    ctx.beginPath();
    ctx.fillStyle = "#7777ff";
    for (i=0;i<points.length;i++) {
      X=drawpoints[i][0];
      Y=drawpoints[i][1];
      rad = radii[i]*zoom;
      if ( X>-rad&&X<width && Y>-rad&&Y<height+rad) {
        ctx.moveTo(X+rad,Y);
        if (i==link && selected != -1) {
          ctx.arc(X,Y,rad*1.2,0,Math.PI*2,true);
        } else {
          ctx.arc(X,Y,rad,0,Math.PI*2,true);
        }
      }
    }
    ctx.fill();
    ctx.closePath();

    //draw zoom controls
    if (zoomdisp) {
      ctx.clearRect(10,10,100,100);
      ctx.clearRect(50,120,20,40);
      if (!zooming) {
        if (zoomhilight==1) {
          ctx.fillStyle = "#f0f0f0";
          ctx.fillRect(50,120,20,20);
        } else if (zoomhilight==-1) {
          ctx.fillStyle = "#f0f0f0";
          ctx.fillRect(50,140,20,20);
        }
      } else {
        if (zooming==1) {
          ctx.fillStyle = "#e0e0f0";
          ctx.fillRect(50,120,20,20);
        } else if (zooming==-1) {
          ctx.fillStyle = "#e0e0f0";
          ctx.fillRect(50,140,20,20);
        }
      }
      ctx.strokeStyle = "#000000";
      ctx.beginPath();
      ctx.strokeRect(50.5,120.5,20,20);
      ctx.strokeRect(50.5,140.5,20,20);
      //draw a plus
      ctx.moveTo(60.5,125.5);
      ctx.lineTo(60.5,135.5);
      ctx.moveTo(55.5,130.5);
      ctx.lineTo(65.5,130.5);
      //draw a minus
      ctx.moveTo(55.5,150.5);
      ctx.lineTo(65.5,150.5);
      ctx.closePath();
      ctx.stroke();
    }

    //make label over hovered node
    if (inLink) {
      ctx.strokeStyle = "#444444";
      ctx.font = "10px sans-serif";
      ctx.beginPath();
      X=drawpoints[link][0];
      Y=drawpoints[link][1];
      rad = radii[link]*zoom+2
      text = points[link][2]+' ('+String(points[link][3])+')';
      ctx.textAlign = 'center';
      textwidth = ctx.measureText(text).width;
      ctx.clearRect(X-textwidth/2-2,Y-rad-16,textwidth+4,13);
      ctx.strokeRect(X-textwidth/2-2,Y-rad-16,textwidth+4,13);
      ctx.strokeText(text,X,Y-rad-7);
      ctx.closePath();
      ctx.stroke();
    }

    if (info) {
      //draw info pane
      ctx.strokeStyle = "#444444";
      ctx.fillStyle = "rgba(253,253,248,0.8)";
      ctx.fillRect(width/2-205,height/2-150,410,126);
      ctx.strokeRect(width/2-205,height/2-150,410,126);
      ctx.textAlign = "left";
      ctx.fillStyle = "#000";
      ctx.font = "14px sans-serif";
      ctx.fillText("We're playing with a \"universe\" type view to help you see all",width/2-195,height/2-130);
      ctx.fillText("of Inta's web. Let us know if you like it or have ideas for it.",width/2-195,height/2-113);
      ctx.fillText("Each dot represents a tag - the size of a dot shows how many",width/2-195,height/2-93);
      ctx.fillText("votes posts have under that tag.",width/2-195,height/2-76);
      ctx.fillText("Lines between dots show that some posts have both tags, with",width/2-195,height/2-56);
      ctx.fillText("more closely related tags having a darker line between them.",width/2-195,height/2-38);
      ctx.beginPath();
      ctx.arc(width/2+205,height/2-150,8,0,Math.PI*2,true);
      if (infoclosehover) {
        ctx.fillStyle = "#f0f0f0";
      } else {
        ctx.fillStyle = "#fff";
      }
      ctx.fill();
      ctx.moveTo(width/2+202,height/2-147);
      ctx.lineTo(width/2+208,height/2-153);
      ctx.moveTo(width/2+208,height/2-147);
      ctx.lineTo(width/2+202,height/2-153);
      ctx.lineCap = "round";
      ctx.lineWidth = "5px";
      ctx.stroke();
    }


    //clear map area
    mapctx.clearRect(0,0,100,100);

    //draw edges in map
    for (i=0;i<edges.length;i++) {
      mapctx.beginPath();
      mapctx.strokeStyle='rgba(0,0,0,'+String(edges[i][2]/100)+')';
      X1=mappoints[edges[i][0]][0];
      Y1=mappoints[edges[i][0]][1];
      X2=mappoints[edges[i][1]][0];
      Y2=mappoints[edges[i][1]][1];
      mapctx.moveTo(X1,Y1);
      mapctx.lineTo(X2,Y2);
      mapctx.stroke();
      mapctx.closePath();
    }

    //draw nodes in map
    mapctx.beginPath();
    mapctx.fillStyle = "#7777ff";
    for (i=0;i<points.length;i++) {
      X=mappoints[i][0];
      Y=mappoints[i][1];
      rad = radii[i]/6;
      mapctx.arc(X,Y,rad,0,Math.PI*2,true);
    }
    mapctx.fill();

    //show view region in map
    mapctx.beginPath();
    mapctx.strokeStyle="#555555";
    mapctx.strokeRect((viewc[0]-minx+0.5*(framer-xrange-width/zoom))*100/framer,(viewc[1]-miny+0.5*(framer-yrange-height/zoom))*100/framer,width*100/(framer*zoom),height*100/(framer*zoom));
    mapctx.stroke();

    //draw sidebar
    sidectx.clearRect(0,0,400,sidebarw);
    sidectx.fillStyle = "#000";
    sidectx.font = "13px sans-serif"
    for (i=0; i<links.length; i++) {
      if (linkhover == i) {
        sidectx.fillStyle = "rgba(200,200,200,0.2)";
        sidectx.fillRect(0,7+15*i,sidebarw,15);
        sidectx.fillStyle = "#000";
      }
      sidectx.fillText(points[links[i]][2],10,20+15*i);
    }
  }
}

function on_mousemove (ev) {
  var x, y;
  var canvrect = canvas.getBoundingClientRect();
  x = ev.clientX - canvrect.left;
  y = ev.clientY - canvrect.top;

  if (panning == 1) {
    var dx = (panpoint[0] - x)/zoom;
    var dy = (panpoint[1] - y)/zoom;
    panpoint[0] = x;
    panpoint[1] = y;
    viewc[0] += dx;
    viewc[1] += dy;
  }
  
  linkhover = -1;

  if (selected != -1) {
    points[link][0] = (x-0.5*width)/zoom+viewc[0];
    points[link][1] = (y-0.5*height)/zoom+viewc[1];
  }
  zoomhilight = 0;
  if (x>10&&x<110 && y>10&&y<180) {
    zoomdisp = 1;
    if (x>50&&x<70) {
      if (y>120&&y<140) {
        zoomhilight = 1
      } else if (y>140&&y<160) {
        zoomhilight = -1
      }
    }
  } else {
    zoomdisp = 0;
  }
  //check if the mouse is over the info pane close button
  if (x>(width/2+197)&&x<(width/2+213) && y<(height/2-142)&&y>(height/2-158)) {
    infoclosehover = 1;
  } else {
    infoclosehover = 0;
  }
  //check if the mouse is over a node
  inLink=false;
  if (selected == -1 && zoomhilight==0) {
    for (i=0;i<drawpoints.length;i++) {
      X=drawpoints[i][0];
      Y=drawpoints[i][1];
      rad = (radii[i]+2)*zoom; // the +2 gives a bit of leeway
      if (x >= (X - rad) && x <= (X + rad) && y<=(Y+rad) && y>= (Y-rad)){
          inLink=true;
          link=i;
      }
    }
  }
}

function on_mousemove_map(ev) {
  zoomdisp = 1;
  var x, y;
  var canvrect = mapcanvas.getBoundingClientRect();
  x = ev.clientX - canvrect.left;
  y = ev.clientY - canvrect.top;
  //move the center of the view to the mouse pointer's location on the map
  if (panning == 1) {
    viewc = [x*framer/100+minx-0.5*(framer-xrange),y*framer/100+miny-0.5*(framer-yrange)];
  }
}

function on_mousemove_sidebar(ev) {
  var y;
  var canvrect = mapcanvas.getBoundingClientRect();
  y = ev.clientY - canvrect.top;
  linkhover = Math.floor(y/15);
}

//this updates a bounding box which is used to ensure that the whole graph is displayed on the map
function updateframe() {
  if (selected >= -1) {
    minx = min(points.map(function(point) {return point[0];}));
    maxx = max(points.map(function(point) {return point[0];}));
    miny = min(points.map(function(point) {return point[1];}));
    maxy = max(points.map(function(point) {return point[1];}));
    minx -= 0.1*Math.abs(minx); //adding the factor of 0.1 gives a margin around the outside
    maxx += 0.1*Math.abs(maxx);
    miny -= 0.1*Math.abs(miny);
    maxy += 0.1*Math.abs(maxy);
    xrange = maxx - minx;
    yrange = maxy - miny;
    framer = Math.max(xrange,yrange);
  }
}

function update() {
  //zoom in/out if one of the buttons is held down
  switch (zooming) {
    case 0:
     break;
    case 1:
      if (zoom < 50) {
        zoom += 0.1*zoom;
      }
     break;
    case -1:
      if (zoom > 0.2) {
        zoom -= 0.1*zoom;
      }
     break;
  }
  
  //these variables are used to calculate the maximum velocity. 'Loading' will appear in the place of the map until the max velocity drops below a certain point
  var V;
  maxv=0;

  for ( i=0; i<points.length; i++ ) {
    var p = points[i];
    var v = velocities[i];
    var f = forces[i];
    if ( selected == -1 || i != link ) {
      v[0] += f[0]/100;
      v[1] += f[1]/100;
      v[0] -= v[0]*damp;
      v[1] -= v[1]*damp;
      p[0] += v[0];
      p[1] += v[1];
    }
    V = Math.pow(Math.pow(v[0],2) + Math.pow(v[1],2),1.5);
    maxv = Math.max(V,maxv);

    f[0] = 0; //resets forces. this has to be done one coordinate at a time to be sure we're resetting forces[i] and not just the temporary variable f
    f[1] = 0;
    
    var dx = p[0]; //attach each point to a weak, invisible spring connected to (0,0). this keeps disconnected pieces from flying away from eachother forever
    var dy = p[1];
    var d = Math.pow(Math.pow(dx,2) + Math.pow(dy,2),0.5);
    var s = 2*(1-10/(0.03*d));
    f[0] -= s*dx;
    f[1] -= s*dy;
  }
  //repel the points from eachother. even though this loops over the same indices as the previous loop, i broke it up so that all the forces would be reset before doing the nested for loop
  for ( i=0; i<points.length; i++ ) {
    var p = points[i];
    var f = forces[i];
    var p1 = [0,0];
    var r1=0;
    for ( j=i+1; j<points.length; j++ ) { //here we update points as pairs rather than looking at each individually. this is why we needed all forces to be reset first (otherwise some forces would be updated as part of a pair and then reset later)
      p1 = points[j];
      f1 = forces[j];
      dx = p[0]-p1[0];
      dy = p[1]-p1[1];
      d2 = dx*dx + dy*dy;
      if (d2<20000) {
        d=Math.pow(d2,1.5);
        f[0] += k*dx/d;
        f[1] += k*dy/d;
        f1[0] -= k*dx/d;
        f1[1] -= k*dy/d;
      }
    }
  }

  //update forces due to springs
  for (i=0; i<edges.length; i++) {
    var e = edges[i];
    var p = points[e[0]];
    var p1 = points[e[1]];
    var f = forces[e[0]];
    var f1 = forces[e[1]];
    var dx = p[0]-p1[0];
    var dy = p[1]-p1[1];
    var d = Math.pow(Math.pow(dx,2) + Math.pow(dy,2),0.5);
    var s = e[2]*stiffness*(1-spread/d)/maxedge;
    f[0] -= s*dx;
    f[1] -= s*dy;
    f1[0] += s*dx;
    f1[1] += s*dy;
    forces[e[0]] = f;
    forces[e[1]] = f1;
  }

  //convert each node's coordinates into points to be drawn in the view and on the map
  drawpoints = points.map(function(point) { return [(point[0]-viewc[0])*zoom+width/2,(point[1]-viewc[1])*zoom+height/2]; });
  mappoints = points.map(function(point) { return [(point[0]-minx+0.5*(framer-xrange))*100/framer,(point[1]-miny+0.5*(framer-yrange))*100/framer]; });

  if (maxv > 200 && loading) {
    draw();
    mapctx.clearRect(0,0,100,100);
    mapctx.textAlign = "center";
    mapctx.strokeText('Loading',50,50);
    mapctx.stroke();
    setTimeout(update,5);
  } else if (loading) {
    loading = 0;
    updateframe();
    draw();
    setTimeout(update,5);
  } else {
    updateframe();
    draw();
    setTimeout(update,5);
  }
}

function on_down(ev) {
  if (inLink) {
    selected = link;
    links.push(link);
  } else {
    var x, y;
    var canvrect = canvas.getBoundingClientRect();
    x = ev.clientX - canvrect.left;
    y = ev.clientY - canvrect.top;
    if (zoomhilight) {
      zooming = zoomhilight;
    } else {
      panpoint = [x,y];
      panning = 1;
    }
    if (infoclosehover) {
      info = 0;
    }
    // console.log([x,y]);
  }
}

function on_down_map(ev) {
  var x, y;
  var canvrect = mapcanvas.getBoundingClientRect();
  x = ev.clientX - canvrect.left;
  y = ev.clientY - canvrect.top;
  viewc = [x*framer/100+minx-0.5*(framer-xrange),y*framer/100+miny-0.5*(framer-yrange)];
  panning = 1;
}

function on_down_sidebar(ev) {
  if (links.length>linkhover) {
    window.open('/{{ method }}/'+points[links[linkhover]][2]);
  }
}

function on_up(e) {
  selected = -1;
  panning = 0;
  zooming = 0;
}

function scroll(ev) {
  if (zoom>=0.2 && zoom<=50) {
    var x, y;
    var canvrect = canvas.getBoundingClientRect();
    x = ev.clientX - canvrect.left;
    y = ev.clientY - canvrect.top;
    var dz = ev.wheelDelta*zoom/1000; //making dz proportional to zoom makes zooming feel more steady
    //adjust the center of the view so that the mouse stays over the same point while zooming. this makes it possible to zoom in on a specific point
    viewc[0] += dz*(x-0.5*width)/(zoom*zoom+zoom*dz);
    viewc[1] += dz*(y-0.5*height)/(zoom*zoom+zoom*dz);
    zoom += dz;
    //put bounds on how zoomed in/out you can be. also reset the center if the zoom isn't reset, otherwise if you keep scrolling after the zoom limit it will keep moving the view pane
    if (zoom>50) {
      zoom = 50;
      viewc[0] -= dz*(x-0.5*width)/(zoom*zoom+zoom*dz);
      viewc[1] -= dz*(y-0.5*height)/(zoom*zoom+zoom*dz);
    } else if (zoom<0.2) {
      zoom = 0.2;
      viewc[0] -= dz*(x-0.5*width)/(zoom*zoom+zoom*dz);
      viewc[1] -= dz*(y-0.5*height)/(zoom*zoom+zoom*dz);
    }
  }
}

//adjust the size and placement of canvases when the window is resized
function resize() {
  var w = window.innerWidth;
  var h = window.innerHeight;
  width = w-sidebarw;
  sidebar.style.left = w-sidebarw;
  height = h;
  canvas.width = w;
  canvas.height = h;
  sidebar.height = h;
  searchinput.style.left = w-sidebarw+10;
  searchinput.style.top = h-searchinput.style.height.slice(0,-2)-10-40;
}

//not used yet in the interface, but if you type in findtag('Health') for example in the console it will center the view on the 'Health' node
function findtag(tagname) {
  search = points.filter(function(p) { return p[2]==tagname; });
  if (search.length) {
    viewc = [search[0][0],search[0][1]];
    link = points.indexOf(search[0]);
    inLink=1;
  }
}

</script>
</html>