<html>
<head>
<style>
.brian_nav .inta_brand {
 color: #ddf;
 display: inline;
 float:left;
 font-size:26px;
 margin: 5px 0 0 10px;
 margin-left: 20px;
 margin-right: 15px;
 border-bottom: 2px solid white;
}
.brian_nav {
  position: fixed;
  top:0%;
  right:0%;
  left:0%;
  z-index: 20000;
  overflow: hidden;
  background-color: black;
  border-bottom: 1px solid #ddf;
}
.nav_row {
  display:inline-block;
  margin-bottom: 0px;
  padding-bottom: 0px;
}
.brian_nav p {
  display:inline-block;
  padding-bottom: 2px;
  margin: 12px 5px 12px 0px;
  font-weight:bold;
  font-size: 15px;
}
.brian_nav p a {
  color: white;
  text-decoration: none;
}
.nav_row--hide p {
  color: white;
}
.brian_nav p a:hover {
  text-decoration: none;
  color: #ddf;
}
.brian_nav .active > a {
  border-bottom: 2px solid white;
  color: #ddf;
}
.underline_title {
 border-bottom: 2px solid white;
}
</style>

</head>
<body onload="initialize();" style="background-color: #ddf">
 <div class="brian_nav">
  <div class="nav_row" id="time_nav">
      <p class="inta_brand"><a href="/{{ method }}" style="color:#ddf" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest Inta link']);" onClick="_gaq.push(['_trackEvent', 'graphtest', 'Inta link']);"> inta </a></p>
        <p {% if method == 'decay1' %}class="active"{% endif %}><a href="/graphtest/decay1" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest 30m']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '30m']);">30m</a></p>
        <p {% if method == 'decay2' %}class="active"{% endif %}><a href="/graphtest/decay2" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest 3h']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '3h']);">3h</a></p>
        <p {% if method == 'decay3' %}class="active"{% endif %}><a href="/graphtest/decay3" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest 1d']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '1d']);">1d</a></p>
        <p {% if method == 'decay4' %}class="active"{% endif %}><a href="/graphtest/decay4" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest 3d']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '3d']);">3d</a></p>
        <p {% if method == 'decay5' %}class="active"{% endif %}><a href="/graphtest/decay5" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest 1w']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '1w']);">1w</a></p>
        <p {% if method == 'decay6' %}class="active"{% endif %}><a href="/graphtest/decay6" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest 4w']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '4w']);">4w</a></p>
        <p {% if method == 'decay7' %}class="active"{% endif %}><a href="/graphtest/decay7" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest 12w']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '12w']);">12w</a></p>
        <p {% if method == 'decay8' %}class="active"{% endif %}><a href="/graphtest/decay8" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest yr']);" onClick="_gaq.push(['_trackEvent', 'graphtest', 'yr']);">yr</a></p>
        <p {% if method == 'votes' %}class="active"{% endif %}><a href="/graphtest/votes" onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest all']);" onClick="_gaq.push(['_trackEvent', 'graphtest', 'all']);">All-time</a></p>
    </div>
</div>

  <div style="display:inline-block; float:left; margin-left: 20px; margin-top: 60px">
    <p style="font-size: 14px; font-weight:bold; width: 400px; float:left;">We're playing with a "universe" type view to see all of Inta's web. Let us know if you like it or have ideas for it. <a href="mailto:christopher.shriver@yale.edu?subject=The Inta Universe"> christopher.shriver@yale.edu</a> is the architect </p> 
    <br/>
    <ul style="font-size: 14px; font-weight:bold; width: 400px; float:left"> 
      <li>Each node (dot) is a tag</li>
        <ul>
          <li>Tags get bigger with more votes</li>
          <li>Hover to see the tag name (and vote count)</li>
          <li>Click to create a link to Inta for that tag</li>
        </ul>
        <br>
      <li>Tags with connecting lines have shared links</li>
        <ul>
          <li>The darker the line, the more links</li>
        </ul>
        <br>
      <li>Click different time periods above to alter the universe</li>
        <ul>
          <li>Tags with 0 votes in a time period will disappear</li>
        </ul>
  </ul>
  </div>
  <div style="display:inline-block; margin-left: 40px; margin-top: 60px">
    <center>
      <div id='tag' style="font-size: 18px; color: black; font-weight: bold">tag:</div>
      <div id='link' onmousedown="_gaq.push(['_trackEvent', '{{ user }}', 'graphtest link click']);" onClick="_gaq.push(['_trackEvent', 'graphtest', 'list link', '{{ user }}']);"></div>
      <br/>
     <div style="-moz-user-select: none;-webkit-user-select: none; position: relative" onselectstart='return false;'>
        <canvas id="viewpane" width="600" height="600" style="border: 1px solid black; background-color:white; margin-bottom: 30px; position: absolute; left: 0; top: 0; z-index: 0">Canvas not supported.</canvas>
        <canvas id="map" width="100" height="100" style="border: 1px solid black; background-color:rgba(255,255,255,0.9); position: absolute; left: 500; top: 0; z-index: 0"></canvas>
      </div>
    </center>
  </div>
  
<!--
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-32641734-1');
ga('send', 'pageview');
-->


</body>
<script type="text/javascript">
var canvas = document.getElementById("viewpane");
var mapcanvas = document.getElementById("map");
var width = 600;
var height = 600;
var ctx=canvas.getContext("2d");
var mapctx=mapcanvas.getContext("2d");
var X;
var Y;
var points={% autoescape off %}{{ points }}{% endautoescape %};
var edges={{ edges }};
var forces=points.map(function(p) { return [0,0]; });
var velocities=points.map(function(p) { return [0,0]; });
var radii=points.map(function(p) { return 2*Math.log(p[3]+1); });
var rad = 3;
var inLink = false;
var link=0;
var drawpoints = points;
var mappoints = points;
var selected = -1;

var loading = 1;

var panpoint = [0,0];
var panning = 0;

var zoomdisp = 1;
var zooming = 0;

var minx = 0;
var maxx = 0;
var miny = 0;
var maxy = 0;
var xrange = 0;
var yrange = 0;
var framer = 0;
var vieww = 600;
var viewc = [300,300];

var damp = 90;
var stiffness = 8;
var spread = 40;
var k = 300000;
var maxv = 0;


function min(array) {
    return Math.min.apply(null,array);
}
function max(array) {
    return Math.max.apply(null,array);
}

var maxedge = max(edges.map(function(e) { return e[2]; }));

function arrangepoints() {
  var l = points.length;
  for (i=0; i<l; i++) {
    var p = points[i];
    p[0] = width/2 + 20*Math.cos(2*Math.PI*i/l);
    p[1] = height/2 + 20*Math.sin(2*Math.PI*i/l);
    points[i] = p;
  }
}

function initialize() {
  //add mouse listeners
    canvas.addEventListener("mousemove", on_mousemove, false);
    mapcanvas.addEventListener("mousemove", on_mousemove_map, false);
    canvas.addEventListener("mousedown", on_down, false);
    mapcanvas.addEventListener("mousedown", on_down_map, false);
    canvas.addEventListener("mouseup", on_up, false);
    mapcanvas.addEventListener("mouseup", on_up, false);
    update();
    updateframe();
    loading = 1;
}

// draw the nodes and edges
function draw() {

  // check if supported
  if(canvas.getContext) {
    //clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    //draw edges
    for (i=0;i<edges.length;i++) {
      ctx.beginPath();
      ctx.strokeStyle='rgba(0,0,0,'+String(edges[i][2]/50)+')';
      X1=drawpoints[edges[i][0]][0];
      Y1=drawpoints[edges[i][0]][1];
      X2=drawpoints[edges[i][1]][0];
      Y2=drawpoints[edges[i][1]][1];
      ctx.moveTo(X1,Y1);
      ctx.lineTo(X2,Y2);
      ctx.stroke();
      ctx.closePath();
    }

    //hilight hovered node
    if (inLink) {
      ctx.fillStyle = "#ddddff";
      ctx.beginPath();
      X=drawpoints[link][0];
      Y=drawpoints[link][1];
      rad = radii[link]+2;
      ctx.moveTo(X+rad,Y);
      ctx.arc(X,Y,rad,0,Math.PI*2,true);
      ctx.fill();
      ctx.fillStyle = "#aaaaff";
      ctx.beginPath();
      rad -= 1;
      ctx.moveTo(X+rad,Y);
      ctx.arc(X,Y,rad,0,Math.PI*2,true);
      ctx.fill();
    }

    //draw the nodes if the are in the view pane
    ctx.beginPath();
    for (i=0;i<points.length;i++) {
      if ( i in collide ) {
        ctx.fillStyle = "#ff7777";
      } else {
        ctx.fillStyle = "#7777ff";
      }
      X=drawpoints[i][0];
      Y=drawpoints[i][1];
      rad = radii[i]*600/vieww;
      if ( X>-rad&&X<width+rad && Y>-rad&&Y<height+rad) {
        ctx.moveTo(X+rad,Y);
        if (i==link && selected != -1) {
          ctx.arc(X,Y,rad+1,0,Math.PI*2,true);
        } else {
          ctx.arc(X,Y,rad,0,Math.PI*2,true);
        }
      }
    }
    ctx.fill();

    //draw zoom controls
    if (zoomdisp) {
      ctx.clearRect(540,120,20,40);
      ctx.strokeStyle = "rgba(0,0,0,1)";
      ctx.beginPath();
      ctx.strokeRect(540,120,20,20);
      ctx.strokeRect(540,140,20,20);
      ctx.stroke();
      ctx.beginPath();
      ctx.strokeStyle = "#000000";
      ctx.moveTo(550,125);
      ctx.lineTo(550,135);
      ctx.moveTo(545,130);
      ctx.lineTo(555,130);
      ctx.moveTo(545,150);
      ctx.lineTo(555,150);
      ctx.stroke();
    }

    //make label over hovered node
    if (inLink) {
      ctx.strokeStyle = "#444444";
      ctx.beginPath();
      X=drawpoints[link][0];
      Y=drawpoints[link][1];
      text = points[link][2];
      ctx.textAlign = 'center';
      textwidth = ctx.measureText(text).width;
      ctx.clearRect(X-textwidth/2-2,Y-rad-17,textwidth+4,14);
      ctx.strokeRect(X-textwidth/2-2,Y-rad-17,textwidth+4,14);
      ctx.strokeText(text,X,Y-rad-7);
      ctx.stroke();
    }


    //clear map area
    mapctx.clearRect(0,0,100,100);

    //draw edges in map
    for (i=0;i<edges.length;i++) {
      mapctx.beginPath();
      mapctx.strokeStyle='rgba(0,0,0,'+String(edges[i][2]/100)+')';
      X1=mappoints[edges[i][0]][0];
      Y1=mappoints[edges[i][0]][1];
      X2=mappoints[edges[i][1]][0];
      Y2=mappoints[edges[i][1]][1];
      mapctx.moveTo(X1,Y1);
      mapctx.lineTo(X2,Y2);
      mapctx.stroke();
      mapctx.closePath();
    }

    //draw nodes in map
    mapctx.beginPath();
    for (i=0;i<points.length;i++) {
      mapctx.fillStyle = "#7777ff";
      X=mappoints[i][0];
      Y=mappoints[i][1];
      rad = radii[i]/6;
      mapctx.moveTo(X+rad,Y);
      mapctx.arc(X,Y,rad,0,Math.PI*2,true);
    }
    mapctx.fill();

    //show view region in map
    mapctx.beginPath();
    mapctx.strokeStyle="555555";
    mapctx.strokeRect((viewc[0]-minx+0.5*(framer-xrange-vieww))*100/framer,(viewc[1]-miny+0.5*(framer-yrange-vieww))*100/framer,vieww*100/framer,vieww*100/framer);
    mapctx.stroke();
  }
}

function on_mousemove (ev) {
  var x, y;
  var canvrect = canvas.getBoundingClientRect();
  x = ev.clientX - canvrect.left;
  y = ev.clientY - canvrect.top;

  if (panning == 1) {
    var dx = (panpoint[0] - x)*vieww/width;
    var dy = (panpoint[1] - y)*vieww/height;
    panpoint[0] = x;
    panpoint[1] = y;
    viewc[0] += dx;
    viewc[1] += dy;
  }
  
  if (selected != -1) {
    points[link][0] = vieww*(x/width-0.5)+viewc[0];
    points[link][1] = vieww*(y/height-0.5)+viewc[1];
  }
  zoomhilight = 0;
  if (x>500 && y>100&&y<180) {
    zoomdisp = 1;
    if (x>540&&x<560) {
      if (y>120&&y<140) {
        zoomhilight = 1
      } else if (y>140&&y<160) {
        zoomhilight = -1
      }
    }
  } else {
    zoomdisp = 0;
  }
  //is the mouse over a node?
  if (selected == -1 && zoomhilight==0) {
    document.body.style.cursor = "";
    inLink=false;
    for (i=0;i<drawpoints.length;i++) {
      X=drawpoints[i][0];
      Y=drawpoints[i][1];
      rad = radii[i]+2; // the +2 gives a bit of leeway
      if (x >= (X - rad) && x <= (X + rad) && y<=(Y+rad) && y>= (Y-rad)){
          inLink=true;
          link=i;
          document.getElementById("tag").innerHTML="tag: "+String(points[link][2])+' ('+String(points[link][3])+')'
      }
    }
  }
}

function on_mousemove_map(ev) {
  zoomdisp = 1;
  var x, y;
  var canvrect = mapcanvas.getBoundingClientRect();
  x = ev.clientX - canvrect.left;
  y = ev.clientY - canvrect.top;
  if (panning == 1) {
    viewc = [x*framer/100+minx-0.5*(framer-xrange),y*framer/100+miny-0.5*(framer-yrange)];
  }
}

function updateframe() {
  if (selected >= -1) {
    minx = min(points.map(function(point) {return point[0];}));
    maxx = max(points.map(function(point) {return point[0];}));
    miny = min(points.map(function(point) {return point[1];}));
    maxy = max(points.map(function(point) {return point[1];}));
    minx -= 0.1*Math.abs(minx);
    maxx += 0.1*Math.abs(maxx);
    miny -= 0.1*Math.abs(miny);
    maxy += 0.1*Math.abs(maxy);
    xrange = maxx - minx;
    yrange = maxy - miny;
    framer = Math.max(xrange,yrange);
  }
}

function update() {
  switch (zooming) {
    case 0:
     break;
    case 1:
     if (vieww > 0) {
      vieww -= 15;
     }
     break;
    case -1:
     vieww += 15;
     break;
  }

  var V;
  collide = [];
  maxv=0;
  for ( i=0; i<points.length; i++ ) {
    var p = points[i];
    var v = velocities[i];
    var f = forces[i];
    var r = radii[i];
    if ( selected == -1 || i != link ) {
      v[0] += f[0]/100;
      v[1] += f[1]/100;
      p[0] += v[0];
      p[1] += v[1];
    }
    V = Math.pow(Math.pow(v[0],2) + Math.pow(v[1],2),1.5);
    maxv = Math.max(V,maxv);

    f[0] = -v[0]*damp; //resets forces and adds damping force
    f[1] = -v[1]*damp;

    var dx = p[0]-width/2; //attach each point to a weak, invisible spring connected to the center
    var dy = p[1]-height/2;
    var d = Math.pow(Math.pow(dx,2) + Math.pow(dy,2),0.5);
    var s = 2*(1-10/(0.03*d));
    f[0] -= s*dx;
    f[1] -= s*dy;

    var p1 = [0,0]; //repel the points from eachother
    var r1=0;
    for ( j=0; j<points.length; j++ ) {
      if ( j != i ) {
        p1 = points[j];
        r1 = radii[j];
        dx = p[0]-p1[0];
        dy = p[1]-p1[1];
        d=Math.pow(Math.pow(dx,2) + Math.pow(dy,2),1.5);
        f[0] += k*dx/d;
        f[1] += k*dy/d;
      }
    }
  }
  for (i=0; i<edges.length; i++) {
    var e = edges[i];
    var p = points[e[0]];
    var p1 = points[e[1]];
    var f = forces[e[0]];
    var f1 = forces[e[1]];
    var dx = p[0]-p1[0]; //update force due to springs
    var dy = p[1]-p1[1];
    var d = Math.pow(Math.pow(dx,2) + Math.pow(dy,2),0.5);
    var lbound = 10;
    if (d<lbound) {
      var s = e[2]*stiffness*(1-spread/lbound)/maxedge;
      f[0] -= s*dx*lbound/d;
      f[1] -= s*dy*lbound/d;
      f1[0] += s*dx*lbound/d;
      f1[1] += s*dy*lbound/d;
      forces[e[0]] = f;
      forces[e[1]] = f1;
    } else {
      var s = e[2]*stiffness*(1-spread/d)/maxedge;
      f[0] -= s*dx;
      f[1] -= s*dy;
      f1[0] += s*dx;
      f1[1] += s*dy;
      forces[e[0]] = f;
      forces[e[1]] = f1;
  }
  }

  drawpoints = points.map(function(point) { return [(point[0]-viewc[0]+vieww/2)*width/vieww,(point[1]-viewc[1]+vieww/2)*height/vieww]; });
  mappoints = points.map(function(point) { return [(point[0]-minx+0.5*(framer-xrange))*100/framer,(point[1]-miny+0.5*(framer-yrange))*100/framer]; });

  if (maxv > 200 && loading) {
    draw();
    mapctx.clearRect(0,0,100,100);
    mapctx.textAlign = "center";
    mapctx.strokeText('Loading',50,50);
    mapctx.stroke();
    setTimeout(update,20);
  } else if (loading) {
    loading = 0;
    updateframe();
    draw();
    setTimeout(update,20);
  } else {
    updateframe();
    draw();
    setTimeout(update,20);
  }

}

function on_down(ev) {
  if (inLink) {
    selected = link;
    document.getElementById("link").innerHTML="<a href = '/votes/"+String(points[link][2])+"' target='_blank'>Go to tag "+ String(points[link][2])+"</a>";
  } else {
    var x, y;
    var canvrect = canvas.getBoundingClientRect();
    x = ev.clientX - canvrect.left;
    y = ev.clientY - canvrect.top;
    if (zoomhilight) {
      zooming = zoomhilight;
    } else {
      panpoint = [x,y];
      panning = 1;
    }
  }
}

function on_down_map(ev) {
  var x, y;
  var canvrect = mapcanvas.getBoundingClientRect();
  x = ev.clientX - canvrect.left;
  y = ev.clientY - canvrect.top;
  viewc = [x*framer/100+minx-0.5*(framer-xrange),y*framer/100+miny-0.5*(framer-yrange)];
  panning = 1;
}

function on_up(e) {
  selected = -1;
  panning = 0;
  zooming = 0;
}

</script>
</html>