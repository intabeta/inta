
<html>
<head>
<style>
.brian_nav .inta_brand {
 color: #ddf;
 display: inline;
 float:left;
 font-size:26px;
 margin: 5px 15px 0px 20px;
 /*border-bottom: 2px solid white;*/
}
.brian_nav {
  position: fixed;
  top:0%;
  right:0%;
  left:0%;
  z-index: 20000;
  overflow: hidden;
  background-color: black;
  border-bottom: 1px solid #000;
  height: 40px;
}
.nav_row {
  display:inline-block;
  margin-bottom: 0px;
  padding-bottom: 0px;
}
.brian_nav p {
  display:inline-block;
  padding-bottom: 2px;
  margin: 12px 5px 12px 0px;
  font-weight:bold;
  font-size: 15px;
}
.brian_nav p a {
  color: white;
  text-decoration: none;
}
.nav_row--hide p {
  color: white;
}
.brian_nav p a:hover {
  text-decoration: none;
  color: #ddf;
}
.brian_nav .active > a {
  border-bottom: 2px solid white;
  color: #ddf;
}
.underline_title {
 border-bottom: 2px solid white;
}

.deleter:hover {
  color:white;
  cursor:default;
}

ul.search {
  margin:0px;
  padding:0px;
}

ul.search li {
  display: inline-block;
  margin:2px 2px;
  padding:2px 2px;
  height:19px;
  border:0px transparent;
  border-style:inset;
  background:#ff7777;
  border-radius: 5px;
  font-family:Arial;
  font-size:15px;
}

#search {
  margin:0px;
}

#results {
  border:1px solid black;
  background-color:rgba(0,0,100,0.1);
}

#resultsul {
  list-style-type:none;
  display:block;
  margin:0px;
  padding:2px;
  font-family:Arial;
}
</style>
</head>
<body onload="initialize();" style="background-color: #ddf">
 <div class="brian_nav">
  <div class="nav_row" id="time_nav">
      <p class="inta_brand"><a href="/votes" style="color:#ddf" onmousedown="_gaq.push(['_trackEvent', '', 'graphtest Inta link']);" onClick="_gaq.push(['_trackEvent', 'graphtest', 'Inta link']);"> inta </a></p>
        <p ><a href="/graphtest/decay1" onmousedown="_gaq.push(['_trackEvent', '', 'graphtest 30m']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '30m']);">30m</a></p>
        <p ><a href="/graphtest/decay2" onmousedown="_gaq.push(['_trackEvent', '', 'graphtest 3h']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '3h']);">3h</a></p>
        <p ><a href="/graphtest/decay3" onmousedown="_gaq.push(['_trackEvent', '', 'graphtest 1d']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '1d']);">1d</a></p>
        <p ><a href="/graphtest/decay4" onmousedown="_gaq.push(['_trackEvent', '', 'graphtest 3d']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '3d']);">3d</a></p>
        <p ><a href="/graphtest/decay5" onmousedown="_gaq.push(['_trackEvent', '', 'graphtest 1w']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '1w']);">1w</a></p>
        <p ><a href="/graphtest/decay6" onmousedown="_gaq.push(['_trackEvent', '', 'graphtest 4w']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '4w']);">4w</a></p>
        <p ><a href="/graphtest/decay7" onmousedown="_gaq.push(['_trackEvent', '', 'graphtest 12w']);" onClick="_gaq.push(['_trackEvent', 'graphtest', '12w']);">12w</a></p>
        <p ><a href="/graphtest/decay8" onmousedown="_gaq.push(['_trackEvent', '', 'graphtest yr']);" onClick="_gaq.push(['_trackEvent', 'graphtest', 'yr']);">yr</a></p>
        <p class="active"><a href="/graphtest/votes" onmousedown="_gaq.push(['_trackEvent', '', 'graphtest all']);" onClick="_gaq.push(['_trackEvent', 'graphtest', 'all']);">All-time</a></p>
    </div>
</div>

  <!-- <div style="display:inline-block; float:left; margin-left: 0px; margin-top: 40px; border: 1px solid black">
    <div id='link' onmousedown="_gaq.push(['_trackEvent', '', 'graphtest link click']);" onClick="_gaq.push(['_trackEvent', 'graphtest', 'list link', '']);"></div>
    <p style="font-size: 14px; font-weight:bold; width: 400px; float:left;">We're playing with a "universe" type view to see all of Inta's web. Let us know if you like it or have ideas for it. <a href="mailto:christopher.shriver@yale.edu?subject=The Inta Universe"> christopher.shriver@yale.edu</a> is the architect </p> 
    <br/>
    <ul style="font-size: 14px; width: 400px; float:left"> 
      <li>Each node (dot) is a tag</li>
        <ul>
          <li>Tags get bigger with more votes</li>
          <li>Hover to see the tag name (and vote count)</li>
          <li>Click to create a link to Inta for that tag</li>
        </ul>
        <br>
      <li>Tags with connecting lines have shared links</li>
        <ul>
          <li>The darker the line, the more links</li>
        </ul>
        <br>
      <li>Click different time periods above to alter the universe</li>
        <ul>
          <li>Tags with 0 votes in a time period will disappear</li>
        </ul>
  </ul>
  </div> -->
  <div style="margin-left: 0px; -moz-user-select: none; -webkit-user-select: none; position: absolute; top: 40px; left:0px;" onselectstart='return false;'>
      <canvas id="viewpane" width="600" height="600" style="border-top: 1px solid black; background-color:rgb(250,250,245); position: absolute; left: 0; top: 29; z-index: 0">Canvas not supported.</canvas>
      <div id="searchbar" style="width:600px; height:29px; background-color:rgb(255,255,250); position:absolute; left:0; top:0; z-index:2; padding:0px">
        <ul id='tagsul' class="search" style="position:absolute; left:2; top:2; z-index:2">
          <li id="searchli">
            <input id='search' type='text' size='50' placeholder="Find tags" style="width:150px; height:19px;" />
          </li>
        </ul>
      </div>
      <canvas id="map" width="100" height="100" style="border: 1px solid black; background-color:rgba(255,255,255,0.7); position: absolute; left: 10; top: 39; z-index: 1"></canvas>
      <div id="results" style="width:300px; height:600px; position:absolute; left:0; top:29; z-index:1">
        <ul id="resultsul">
          <li>Result 1</li>
          <li>Result 2</li>
        </ul>
      </div>
  </div>
  
<!--
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-32641734-1');
ga('send', 'pageview');
-->


</body>
<script type="text/javascript">
var canvas = document.getElementById("viewpane");
var mapcanvas = document.getElementById("map");
var resultsdiv = document.getElementById("results");
var searchinput = document.getElementById("search");
var searchbar = document.getElementById("searchbar");
var tagsul = document.getElementById("tagsul");
var searchli = document.getElementById("searchli");

var width = 600;
var height = 600;

var ctx=canvas.getContext("2d");
var mapctx=mapcanvas.getContext("2d");

var points={% autoescape off %}{{ points }}{% endautoescape %};
var edges={{ edges }};
var forces=points.map(function(p) { return [0,0]; });
var velocities=points.map(function(p) { return [0,0]; });
var radii=points.map(function(p) { return 2*Math.log(p[3]+1); });
var pointslen = points.length;
var inLink = false;
var link=0;
var drawpoints = points;
var mappoints = points;

var selected = -1;
var links = [];
var linkhover = -1;
var activetags = [];
var connectedtags = [];
var activeedges = [];

var loading = 1;
var info = 0;
var infoclosehover = 0;

var panpoint = [0,0];
var panning = 0;

var zoomdisp = 1;
var zooming = 0;
var zoomhilight = 0;

var minx = 0;
var maxx = 0;
var miny = 0;
var maxy = 0;
var xrange = 0;
var yrange = 0;
var framer = 0;
var zoom = 2; //equal to canvas width divided by view width
var viewc = [300,300];

var damp = 0.5;
var stiffness = 3;
var spread = 40;
var k = 300000;
var maxv = 0;

var times = 0;
var timesum = 0;
var timelist = [];


function min(array) {
    return Math.min.apply(null,array);
}
function max(array) {
    return Math.max.apply(null,array);
}

var maxedge = max(edges.map(function(e) { return e[2]; }));

function arrangepoints() {
  var l = points.length;
  for (i=0; i<l; i++) {
    var p = points[i];
    p[0] = width/2 + 20*Math.cos(2*Math.PI*i/l);
    p[1] = height/2 + 20*Math.sin(2*Math.PI*i/l);
    points[i] = p;
  }
}

function initialize() {
  //add mouse listeners
    canvas.addEventListener("mousemove", on_mousemove, false);
    mapcanvas.addEventListener("mousemove", on_mousemove_map, false);
    canvas.addEventListener("mousedown", on_down, false);
    mapcanvas.addEventListener("mousedown", on_down_map, false);
    canvas.addEventListener("mouseup", on_up, false);
    mapcanvas.addEventListener("mouseup", on_up, false);
    canvas.addEventListener("mousewheel",function(ev){
      scroll(ev);
      ev.preventDefault();
      return false;
    },false);
    searchbar.addEventListener('mousedown', on_down_searchbar, false);
    window.addEventListener("resize", resize, false);
    searchinput.onkeydown = function(ev) {if (ev.keyCode==13) {search(searchinput.value);}};
    var w = window.innerWidth;
    var h = window.innerHeight;
    width = w;
    height = h-40;
    canvas.width = w;
    canvas.height = h-canvas.getBoundingClientRect().top;
    searchbar.style.width = w;
    results.style.left = w-results.getBoundingClientRect().width;
    results.style.height = h-canvas.getBoundingClientRect().top;
    // searchinput.style.left = w-sidebarw+10;
    // searchinput.style.top = h-searchinput.style.height.slice(0,-2)-10-40;
    // searchinput.style.width = sidebarw-20;
    update();
    updateframe();
    loading = 1;
}

// draw things
function draw() {
  // check if supported
  if(canvas.getContext) {
    //clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    //draw edges
    if (activetags.length>0) {
      ctx.strokeStyle='rgba(0,0,0,0.02)';
    } else {
      ctx.strokeStyle='rgba(0,0,0,0.05)';
    }
    ctx.beginPath();
    for (i=0;i<edges.length;i++) {
      // ctx.strokeStyle='rgba(0,0,0,'+String(edges[i][2]/50)+')';
      var edge = edges[i];
      var P1=drawpoints[edge[0]];
      var P2=drawpoints[edge[1]];
      ctx.moveTo(P1[0],P1[1]);
      ctx.lineTo(P2[0],P2[1]);
    }
    ctx.stroke();
    ctx.closePath();

    //draw active edges
    ctx.strokeStyle='rgba(100,0,200,0.05)';
    ctx.beginPath();
    for (i=0;i<activeedges.length;i++) {
      // ctx.strokeStyle='rgba(0,0,0,'+String(edges[i][2]/50)+')';
      var edge = activeedges[i];
      var P1=drawpoints[edge[0]];
      var P2=drawpoints[edge[1]];
      ctx.moveTo(P1[0],P1[1]);
      ctx.lineTo(P2[0],P2[1]);
    }
    ctx.stroke();
    ctx.closePath();

    //hilight hovered node
    if (inLink) {
      if (activetags.indexOf(link)>-1) {
        ctx.fillStyle = "#ffdddd";
      } else {
        ctx.fillStyle = "#ddddff";
      }
      ctx.beginPath();
      var point = drawpoints[link];
      var X=point[0];
      var Y=point[1];
      var rad = radii[link]*1.2*zoom;
      ctx.moveTo(X+rad,Y);
      ctx.arc(X,Y,rad,0,Math.PI*2,true);
      ctx.fill();
      ctx.closePath();
      if (activetags.indexOf(link)>-1) {
        ctx.fillStyle = "#ffaaaa";
      } else {
        ctx.fillStyle = "#aaaaff";
      }
      ctx.beginPath();
      rad *= 0.9;
      ctx.moveTo(X+rad,Y);
      ctx.arc(X,Y,rad,0,Math.PI*2,true);
      ctx.fill();
    }

    //draw the nodes if they are in the view pane
    ctx.beginPath();
    if (activetags.length>0) {
      ctx.fillStyle = "rgba(112,112,255,0.1)";
    } else {
      ctx.fillStyle = "#7777ff";
    }
    for (i=0;i<pointslen;i++) {
      var point = drawpoints[i];
      var X=point[0];
      var Y=point[1];
      var rad = radii[i]*zoom;
      if ( X>-rad&&X<width && Y>-rad&&Y<(height+rad)) {
        ctx.moveTo(X+rad,Y);
          if (i==link && selected != -1) {
            ctx.arc(X,Y,rad*1.2,0,Math.PI*2,true);
          } else {
            ctx.arc(X,Y,rad,0,Math.PI*2,true);
          }
      }
    }
    ctx.fill();
    ctx.closePath();

    //draw nodes for connected tags
    ctx.beginPath();
    ctx.fillStyle = "#7777ff";
    for (j=0;j<connectedtags.length;j++) {
      var i = connectedtags[j];
      var point = drawpoints[i];
      var X=point[0];
      var Y=point[1];
      var rad = radii[i]*zoom;
      if ( X>-rad&&X<width && Y>-rad&&Y<(height+rad)) {
        ctx.moveTo(X+rad,Y);
          if (i==link && selected != -1) {
            ctx.arc(X,Y,rad*1.2,0,Math.PI*2,true);
          } else {
            ctx.arc(X,Y,rad,0,Math.PI*2,true);
          }
      }
    }
    ctx.fill();
    ctx.closePath();

    //draw nodes for active tags
    ctx.beginPath();
    ctx.fillStyle = "#ff7777";
    for (j=0;j<activetags.length;j++) {
      var i = activetags[j];
      var point = drawpoints[i];
      var X=point[0];
      var Y=point[1];
      var rad = radii[i]*zoom;
      if ( X>-rad&&X<width && Y>-rad&&Y<(height+rad)) {
        ctx.moveTo(X+rad,Y);
          if (i==link && selected != -1) {
            ctx.arc(X,Y,rad*1.2,0,Math.PI*2,true);
          } else {
            ctx.arc(X,Y,rad,0,Math.PI*2,true);
          }
      }
    }
    ctx.fill();
    ctx.closePath();

    //draw zoom controls
    if (zoomdisp) {
      ctx.clearRect(10,10,100,100);
      ctx.clearRect(50,120,20,40);
      if (!zooming) {
        if (zoomhilight==1) {
          ctx.fillStyle = "#f0f0f0";
          ctx.fillRect(50,120,20,20);
        } else if (zoomhilight==-1) {
          ctx.fillStyle = "#f0f0f0";
          ctx.fillRect(50,140,20,20);
        }
      } else {
        if (zooming==1) {
          ctx.fillStyle = "#e0e0f0";
          ctx.fillRect(50,120,20,20);
        } else if (zooming==-1) {
          ctx.fillStyle = "#e0e0f0";
          ctx.fillRect(50,140,20,20);
        }
      }
      ctx.strokeStyle = "#000000";
      ctx.beginPath();
      ctx.strokeRect(50.5,120.5,20,20);
      ctx.strokeRect(50.5,140.5,20,20);
      ctx.moveTo(60.5,125.5);
      ctx.lineTo(60.5,135.5);
      ctx.moveTo(55.5,130.5);
      ctx.lineTo(65.5,130.5);
      ctx.moveTo(55.5,150.5);
      ctx.lineTo(65.5,150.5);
      ctx.closePath();
      ctx.stroke();
    }

    //make label over hovered node
    if (inLink) {
      ctx.strokeStyle = "#747474";
      ctx.font = "10px sans-serif";
      ctx.beginPath();
      var point = drawpoints[link];
      var X=point[0];
      var Y=point[1];
      var rad = radii[link]*zoom+2;
      text = points[link][2]+' ('+String(points[link][3])+')';
      ctx.textAlign = 'center';
      textwidth = ctx.measureText(text).width;
      ctx.clearRect(X-textwidth/2-2,Y-rad-16,textwidth+4,13);
      ctx.strokeRect(Math.round(X)-textwidth/2-2,Math.round(Y-rad)-16.5,textwidth+4,13);
      ctx.fillStyle = "#343434";
      ctx.fillText(text,Math.round(X),Math.round(Y-rad)-7);
      ctx.closePath();
      ctx.stroke();
    }

    if (info) {
      //draw info pane
      ctx.strokeStyle = "#444444";
      ctx.fillStyle = "rgba(253,253,248,0.8)";
      ctx.fillRect(width/2-205,height/2-150,410,126);
      ctx.strokeRect(width/2-205,height/2-150,410,126);
      ctx.textAlign = "left";
      ctx.fillStyle = "#000";
      ctx.font = "14px sans-serif";
      ctx.fillText("We're playing with a \"universe\" type view to help you see all",width/2-195,height/2-130);
      ctx.fillText("of Inta's web. Let us know if you like it or have ideas for it.",width/2-195,height/2-113);
      ctx.fillText("Each dot represents a tag - the size of a dot shows how many",width/2-195,height/2-93);
      ctx.fillText("votes posts have under that tag.",width/2-195,height/2-76);
      ctx.fillText("Lines between dots show that some posts have both tags, with",width/2-195,height/2-56);
      ctx.fillText("more closely related tags having a darker line between them.",width/2-195,height/2-38);
      ctx.beginPath();
      ctx.arc(width/2+205,height/2-150,8,0,Math.PI*2,true);
      if (infoclosehover) {
        ctx.fillStyle = "#f0f0f0";
      } else {
        ctx.fillStyle = "#fff";
      }
      ctx.fill();
      ctx.moveTo(width/2+202,height/2-147);
      ctx.lineTo(width/2+208,height/2-153);
      ctx.moveTo(width/2+208,height/2-147);
      ctx.lineTo(width/2+202,height/2-153);
      ctx.lineCap = "round";
      ctx.lineWidth = "5px";
      ctx.stroke();
    }
  }
}

function drawmap() {
  //clear map area
  mapctx.clearRect(0,0,100,100);

  //draw edges in map
  mapctx.beginPath();
  mapctx.strokeStyle='rgba(0,0,0,0.03)';
  for (i=0;i<edges.length;i++) {
    //mapctx.strokeStyle='rgba(0,0,0,'+String(edges[i][2]/100)+')';
    var edge = edges[i];
    var P1 = mappoints[edge[0]];
    var P2 = mappoints[edge[1]];
    mapctx.moveTo(P1[0],P1[1]);
    mapctx.lineTo(P2[0],P2[1]);
  }
  mapctx.stroke();
  mapctx.closePath();

  //draw nodes in map
  mapctx.beginPath();
  mapctx.fillStyle = "#7777ff";
  for (i=0;i<pointslen;i++) {
    var rad = radii[i]/6;
    var P = mappoints[i];
    var X=P[0];
    var Y=P[1];
    mapctx.moveTo(X+rad,Y);
    mapctx.arc(X,Y,rad,0,Math.PI*2,true);
  }
  mapctx.fill();

  //show view region in map
  mapctx.beginPath();
  mapctx.strokeStyle="#555555";
  mapctx.strokeRect((viewc[0]-minx+0.5*(framer-xrange-width/zoom))*100/framer,(viewc[1]-miny+0.5*(framer-yrange-height/zoom))*100/framer,width*100/(framer*zoom),height*100/(framer*zoom));
  mapctx.stroke();
  setTimeout(drawmap, 200);

  if (loading) {
    mapctx.fillStyle = '#000000';
    mapctx.clearRect(0,0,100,100);
    mapctx.textAlign = "center";
    mapctx.fillText('Loading',50,50);
  }
}

function on_mousemove (ev) {
  var x, y;
  var canvrect = canvas.getBoundingClientRect();
  x = ev.clientX - canvrect.left;
  y = ev.clientY - canvrect.top;

  linkhover = -1;

  if (panning == 1) {
    var dx = (panpoint[0] - x)/zoom;
    var dy = (panpoint[1] - y)/zoom;
    panpoint[0] = x;
    panpoint[1] = y;
    viewc[0] += dx;
    viewc[1] += dy;
  }
  
  if (selected != -1) {
    points[link][0] = (x-0.5*width)/zoom+viewc[0];
    points[link][1] = (y-0.5*height)/zoom+viewc[1];
  }
  zoomhilight = 0;
  if (x>10&&x<110 && y>10&&y<180) {
    zoomdisp = 1;
    if (x>50&&x<70) {
      if (y>120&&y<140) {
        zoomhilight = 1
      } else if (y>140&&y<160) {
        zoomhilight = -1
      }
    }
  } else {
    zoomdisp = 0;
  }
  //is the mouse over a node?
  if (x>(width/2+197)&&x<(width/2+213) && y<(height/2-142)&&y>(height/2-158)) {
    infoclosehover = 1;
  } else {
    infoclosehover = 0;
  }
  inLink=false;
  if (selected == -1 && zoomhilight==0) {
    for (i=0;i<pointslen;i++) {
      var P = drawpoints[i];
      var X=P[0];
      var Y=P[1];
      var rad = (radii[i]+2)*zoom; // the +2 gives a bit of leeway
      if (x >= (X - rad) && x <= (X + rad) && y<=(Y+rad) && y>= (Y-rad)){
          inLink=true;
          link=i;
      }
    }
  }
}

function on_mousemove_map(ev) {
  zoomdisp = 1;
  var x, y;
  var canvrect = mapcanvas.getBoundingClientRect();
  x = ev.clientX - canvrect.left;
  y = ev.clientY - canvrect.top;
  if (panning == 1) {
    viewc = [x*framer/100+minx-0.5*(framer-xrange),y*framer/100+miny-0.5*(framer-yrange)];
  }
}

function updateframe() {
  if (selected >= -1) {
    minx = min(points.map(function(point) {return point[0];}));
    maxx = max(points.map(function(point) {return point[0];}));
    miny = min(points.map(function(point) {return point[1];}));
    maxy = max(points.map(function(point) {return point[1];}));
    minx -= 0.1*Math.abs(minx);
    maxx += 0.1*Math.abs(maxx);
    miny -= 0.1*Math.abs(miny);
    maxy += 0.1*Math.abs(maxy);
    xrange = maxx - minx;
    yrange = maxy - miny;
    framer = Math.max(xrange,yrange);
  }
}

function update() {
  var t0 = Date.now();
  switch (zooming) {
    case 0:
     break;
    case 1:
      if (zoom < 50) {
        zoom += 0.1*zoom;
      }
     break;
    case -1:
      if (zoom > 0.2) {
        zoom -= 0.1*zoom;
      }
     break;
  }
  
  var V;
  collide = [];
  maxv=0;

  for ( i=0; i<pointslen; i++ ) {
    var p = points[i];
    var v = velocities[i];
    var f = forces[i];
    if ( selected == -1 || i != link ) {
      v[0] += f[0]/100;
      v[1] += f[1]/100;
      v[0] -= v[0]*damp;
      v[1] -= v[1]*damp;
      p[0] += v[0];
      p[1] += v[1];
    }
    V = Math.pow(v[0]*v[0] + v[1]*v[1],1.5);
    maxv = Math.max(V,maxv);

    f[0] = 0; //resets forces
    f[1] = 0;
    
    var dx = p[0]; //attach each point to a weak, invisible spring connected to (0,0)
    var dy = p[1];
    var d = Math.sqrt(dx*dx + dy*dy);
    var s = 2-1/(0.0015*d);
    f[0] -= s*dx;
    f[1] -= s*dy;
  }
  //repel the points from eachother (if they're close enough)
  for ( i=0; i<pointslen; i++ ) {
    var p = points[i];
    var f = forces[i];
    for ( j=i+1; j<pointslen; j++ ) {
      var p1 = points[j];
      var dx = p[0]-p1[0];
      var dy = p[1]-p1[1];
      var d2 = dx*dx + dy*dy;
      if (d2<30000) {
        var f1 = forces[j];
        var d=Math.pow(d2,1.5);
        f[0] += k*dx/d;
        f[1] += k*dy/d;
        f1[0] -= k*dx/d;
        f1[1] -= k*dy/d;
      }
    }
  }

  for (i=0; i<edges.length; i++) {
    var e = edges[i];
    var p = points[e[0]];
    var p1 = points[e[1]];
    var f = forces[e[0]];
    var f1 = forces[e[1]];
    var dx = p[0]-p1[0]; //update force due to springs
    var dy = p[1]-p1[1];
    var d = Math.sqrt(dx*dx + dy*dy);
    var s = e[2]*stiffness*(1-spread/d)/maxedge;
    f[0] -= s*dx;
    f[1] -= s*dy;
    f1[0] += s*dx;
    f1[1] += s*dy;
    forces[e[0]] = f;
    forces[e[1]] = f1;
  }

  drawpoints = points.map(function(point) { return [(point[0]-viewc[0])*zoom+width/2,(point[1]-viewc[1])*zoom+height/2]; });
  mappoints = points.map(function(point) { return [(point[0]-minx+0.5*(framer-xrange))*100/framer,(point[1]-miny+0.5*(framer-yrange))*100/framer]; });

  if (maxv > 200 && loading) {
    draw();
    setTimeout(update,50);
  } else if (loading) {
    loading = 0;
    updateframe();
    draw();
    drawmap();
    setTimeout(update,50);
  } else {
    updateframe();
    draw();
    setTimeout(update,50);
  }
  t = Date.now()-t0;
  timelist.push(t);
  times++;
  timesum += t;
}

function on_down(ev) {
  if (inLink) {
    selected = link;
    activeindex = activetags.indexOf(link);
    if (activeindex>-1) {
      activetags.splice(activeindex,1);
      tagsul.removeChild(tagsul.children[activeindex]);
    } else {
      activetags.push(link);
      addTagLi(points[link][2]);
    }
    calcConnected();
  } else {
    var x, y;
    var canvrect = canvas.getBoundingClientRect();
    x = ev.clientX - canvrect.left;
    y = ev.clientY - canvrect.top;
    if (zoomhilight) {
      zooming = zoomhilight;
    } else {
      panpoint = [x,y];
      panning = 1;
    }
    if (infoclosehover) {
      info = 0;
    }
    // console.log([x,y]);
  }
}

function on_down_map(ev) {
  var x, y;
  var canvrect = mapcanvas.getBoundingClientRect();
  x = ev.clientX - canvrect.left;
  y = ev.clientY - canvrect.top;
  viewc = [x*framer/100+minx-0.5*(framer-xrange),y*framer/100+miny-0.5*(framer-yrange)];
  panning = 1;
}

function on_down_searchbar(ev) {
  var t = ev.target;
  if (t.classList.contains('deleter')) {
    tag = points.filter(function(p) { return p[2]==t.parentElement.firstChild.data.slice(0,-2) })[0];
    link = points.indexOf(tag);
    activeindex = activetags.indexOf(link);
    activetags.splice(activeindex,1);
    calcConnected();
    t.parentElement.parentElement.removeChild(t.parentElement);
  }
}

function on_up(e) {
  selected = -1;
  panning = 0;
  zooming = 0;
}

function scroll(ev) {
  if (zoom>=0.2 && zoom<=50) {
    var x, y;
    var canvrect = canvas.getBoundingClientRect();
    x = ev.clientX - canvrect.left;
    y = ev.clientY - canvrect.top;
    var dz = ev.wheelDelta*zoom/1000;
    viewc[0] += dz*(x-0.5*width)/(zoom*zoom+zoom*dz);
    viewc[1] += dz*(y-0.5*height)/(zoom*zoom+zoom*dz);
    // (point[0]-viewc[0]+vieww/2)*width/vieww
    zoom += dz;
    if (zoom>50) {
      zoom = 50;
      viewc[0] -= dz*(x-0.5*width)/(zoom*zoom+zoom*dz);
      viewc[1] -= dz*(y-0.5*height)/(zoom*zoom+zoom*dz);
    } else if (zoom<0.2) {
      zoom = 0.2;
      viewc[0] -= dz*(x-0.5*width)/(zoom*zoom+zoom*dz);
      viewc[1] -= dz*(y-0.5*height)/(zoom*zoom+zoom*dz);
    }
  }
}

function resize() {
  var w = window.innerWidth;
  var h = window.innerHeight;
  width = w;
  height = h;
  canvas.width = w;
  canvas.height = h;
  results.style.left = w-results.getBoundingClientRect().width;
  results.style.height = h-canvas.getBoundingClientRect().top;
  // searchinput.style.left = w-sidebarw+10;
  // searchinput.style.top = h-searchinput.style.height.slice(0,-2)-10-40;
  searchbar.style.width = w;
}

function areconnected(tag1,tag2) {
  search = edges.filter(function(e) { return e[0]==tag1 && e[1]==tag2; });
  if (search) {
    return 1;
  } else {
    return -1;
  }
}

function connectedto(tag) {
  var search = edges.filter(function(e) { return e[0]==tag || e[1] == tag; });
  var result = [];
  search.map(function(e) { result.push(e[0],e[1]); });
  return result.filter(function(t) { return t != tag; });
}

function calcConnected() {
  // connectedtags = []; //use top three lines for 'or' logic
  // activetags.map(function(tag) { connectedtags.push.apply(connectedtags,connectedto(tag)); }); //add all tags connected to active tags
  // connectedtags = connectedtags.filter(function(tag, pos) { return connectedtags.indexOf(tag) == pos; }); //filter out duplicates
  connectedtags = connectedto(activetags[0]); //start with all tags connected to first active tag
  activetags.map(function(tag1) { //filter out tags not connected to all of the active tags
    connectedtags = connectedtags.filter(function(tag2) { return connectedto(tag1).indexOf(tag2) > -1; });
  });
  var tagslist = activetags.concat(connectedtags); //list of all active and connected tags
  activeedges = edges.filter(function(e) { //figure out which edges are active
    return (tagslist.indexOf(e[0])>-1)&&(tagslist.indexOf(e[1])>-1);
  });
  // for (var i=0; i<activetags.length; i++) {
  //   for (var j=0; j<connectedtags.length; j++) {
  //     activeedges.push([activetags[i],connectedtags[j]],[connectedtags[j],activetags[i]]);
  //   }
  // }
  // console.log(activeedges);
  // activeedges = edges.map(function(e, pos) {
  //   if (activeedges.indexOf([e[0],e[1]])>-1) {
  //     return pos;
  //   } else {
  //     return -1;
  //   }
  // });
  // console.log(activeedges);
  // activeedges = activeedges.filter(function(e) { return e>-1; });
}

function search(tagnames) {
  var tags = tagnames.split(', ');
  var newactivetags = tags.map(function(tag) { return points.filter(function(p) { return p[2]==tag; }); });
  newactivetags = newactivetags.filter(function(tag) {return tag.length>0; });
  var length = newactivetags.length;
  if (length>0) {
    var sum = [0,0];
    var xrange = [0,0];
    var yrange = [0,0];
    newactivetags.map(function(tag) {
      sum[0]+=tag[0][0];
      sum[1]+=tag[0][1];
      xrange[0] = Math.min(xrange[0],tag[0][0]);
      xrange[1] = Math.max(xrange[1],tag[0][0]);
      yrange[0] = Math.min(yrange[0],tag[0][1]);
      yrange[1] = Math.max(yrange[1],tag[0][1]);
    });
    viewc = [sum[0]/length,sum[1]/length];
    xrange = 2*Math.max(Math.abs(xrange[1]-viewc[0]),Math.abs(xrange[0]-viewc[0]));
    yrange = 2*Math.max(Math.abs(yrange[1]-viewc[1]),Math.abs(yrange[0]-viewc[1]));
    if (length>1) { zoom = Math.min(width/xrange,height/yrange); }
    newactivetags = newactivetags.map(function(tag) { return points.indexOf(tag[0]); });
    newactivetags = newactivetags.filter(function(tag) { return activetags.indexOf(tag)==-1; });
    newactivetags.map(function(link) {
      var tag = points[link];
      addTagLi(tag[2]);
    });
    activetags = activetags.concat(newactivetags);
    searchinput.value="";
    calcConnected();
  }
}

function addTagLi(tagname) {
  var newli = document.createElement('li');
  var txt = document.createTextNode(tagname+' [');
  var newspan = document.createElement('span');
  newspan.setAttribute('class','deleter');
  var x = document.createTextNode('x');
  var txt2 = document.createTextNode(']');
  newspan.appendChild(x);
  newli.appendChild(txt);
  newli.appendChild(newspan);
  newli.appendChild(txt2);
  tagsul.insertBefore(newli,searchli);
}

</script>
</html>